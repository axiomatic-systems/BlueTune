import sys
import os
import imp
from glob import glob

#######################################################
# reusable functions and data structures
#######################################################
def LoadTool(name, env, **kw):
    config_path = GetBuildPath('#/Build/Tools/SCons')
    file, path, desc = imp.find_module(name, [config_path])
    module = imp.load_module(name, file, path, desc)
    module.generate(env, **kw)

def MergeListUnique(item_list, items):
    for item in items: 
        if not item in item_list: item_list.append(item)

def MergeItemUnique(item_list, item):
    if not item in item_list: item_list.append(item)
            
def GlobSources(drct, patterns, excluded_files=[]):
    root = GetBuildPath(GetDirPath(drct))
    files = []
    for pattern in Split(patterns):
        files += glob(root+'/'+pattern)
    return [drct+'/'+os.path.basename(x) for x in  files if os.path.basename(x) not in excluded_files]

def GetDirPath(drct):
    for key in SourceDirLookup.keys():
        if drct.startswith(key):
            return SourceDirLookup[key]+drct[len(key):]
    return '#/'+drct
    
def DeclareBuildDir(env, drct):
    env.BuildDir(drct, GetDirPath(drct), duplicate=0)
    
def GetIncludeDirs(modules, exclude=None):
    dirs = []
    for module in Split(modules):
        if Modules.has_key(module) and not module == exclude:
            MergeListUnique(dirs, Modules[module].GetIncludeDirs())
        else:
            MergeItemUnique(dirs, GetDirPath(module))
    return dirs
    
def GetLibraries(modules):
    libs = []
    for module in Split(modules):
        if module in libs: continue
        if Modules.has_key(module):
            dep_libs = Modules[module].GetLibraries()
            libs = [lib for lib in libs if not lib in dep_libs]+dep_libs
        else:
            libs.append(module)
    return libs

def GetLibraryDirs(modules):
    lib_dirs = []
    for module in modules:
        if Modules.has_key(module):
            MergeListUnique(lib_dirs, Modules[module].GetLibraryDirs())
    return lib_dirs

Modules = {}
class Module:
    def __init__(self, name, 
                 included_modules = [], 
                 linked_modules   = [],
                 lib_dirs         = []):
        self.name             = name
        self.included_modules = included_modules
        self.linked_modules   = linked_modules
        self.lib_dirs         = [GetDirPath(dir) for dir in lib_dirs]
        self.product          = []
        Modules[name]         = self        
        
    def GetLibraries(self):
        return self.product+GetLibraries(self.linked_modules)
        
    def GetLibraryDirs(self):
        return self.lib_dirs+GetLibraryDirs(self.linked_modules)

    def GetIncludeDirs(self):
        return GetIncludeDirs(self.included_modules, self.name)

    
class BuildModule(Module):
    def __init__(self, name, 
                 build_source_dirs     = ['.'], 
                 build_source_files    = {},
                 source_root           = 'Source',
                 build_source_pattern  = ['*.c', '*.cpp'], 
                 build_include_dirs    = [], 
                 included_modules      = [], 
                 included_only_modules = [],
                 linked_modules        = [],
                 environment           = None,
                 excluded_files        = [],
                 extra_cpp_defines     = {},
                 extra_lib_dirs        = [],
                 type                  = 'StaticLibrary') :

        # store this new object in the module dictionary
        build_source_dirs = [source_root+'/'+drct for drct in build_source_dirs]
        Module.__init__(self, 
                        name, 
                        Split(included_modules)+Split(included_only_modules)+Split(build_source_dirs), 
                        Split(linked_modules)+Split(included_modules),
                        extra_lib_dirs)
        self.build_include_dirs = build_include_dirs
        self.type               = type
        
        if environment is None:
            self.env = env.Copy()
        else:
            self.env = environment.Copy()
        self.env.Append(CPPDEFINES = extra_cpp_defines)
        
        # for each source drct to build, create a BuildDir
        # to say where we want the object files to be built,
        # and compute the list of source files to build
        sources = []
        for drct in Split(build_source_dirs):
            DeclareBuildDir(self.env, drct)
            sources += GlobSources(drct, build_source_pattern, excluded_files)
            
        # add cherry-picked files
        for drct in build_source_files.keys():
            pattern = build_source_files[drct]
            if drct.startswith('/'):
                drct_path = drct[1:]
            else:
                drct_path = source_root+'/'+drct
            DeclareBuildDir(self.env, drct_path)
            sources += GlobSources(drct_path, pattern)

        # calculate our build include path
        cpp_path = GetIncludeDirs(Split(self.build_include_dirs) + Split(build_source_dirs) + self.included_modules + self.linked_modules)

        # check that the source list is not empty
        if len(sources) == 0:
            raise 'Module '+name+' has no sources'
        
        # the product is a library
        self.env.AppendUnique(CPPDEFINES=self.env['BLT_GLOBAL_CPP_DEFINES'])
        self.env.AppendUnique(CPPPATH=cpp_path)
        if type == 'SharedLibrary':
            libs = GetLibraries(Split(linked_modules))
            self.product = self.env.SharedLibrary(target=name, LIBS=libs, source=sources)
            self.env.Alias(name, self.product)
        elif type == 'StaticLibrary':
            self.product = self.env.Library(target=name, source=sources)
            self.env.Alias(name, self.product)
        elif type == 'Executable':
            # libraries    
            libs = GetLibraries(linked_modules)
            lib_dirs = GetLibraryDirs(linked_modules)
            self.product = self.env.Program(target=name.lower(), source=sources, LIBS=libs, LIBPATH=lib_dirs, CPPPATH=cpp_path)
            self.env.Alias(name, self.product)    
        

    
        
#######################################################
# Main Build
#######################################################
Import("env")

env.Default('BtPlay', 'BtController')

SourceDirLookup = {}

env['NPT_EXTRA_LIBS'] = ''
env['ATX_EXTRA_LIBS'] = ''
env['BLT_EXTRA_LIBS'] = ''

### global settings
if env['build_config'] == 'Debug':
	env['BLT_GLOBAL_CPP_DEFINES'] = {'BLT_DEBUG':None, 'ATX_CONFIG_ENABLE_LOGGING':None}
else:
	env['BLT_GLOBAL_CPP_DEFINES'] = {'NDEBUG':None}

### try to read in any target specific configuration
target_config_file = env.GetBuildPath('#/Build/Targets/'+env['target']+'/Config.scons')
if os.path.exists(target_config_file):
    # Load the target-specific config file    
    execfile(target_config_file)

### extra plugins
if env.has_key('extra_plugins'): 
    env['BLT_PLUGINS'] += Split(env['extra_plugins'])
    
#######################################################
# modules
#
# Usage:
#
# The LibraryModule() function declares a code module
# The included_modules parameter is a list of all the modules and/or directories
# that will be added to the include path when building this module AND to
# the include path of any other module that depends on this one.
# The linked_modules parameter is a list of all the modules and/or directories
# that are necessary to build this module. These modules will be added to
# the include path of this module, but not to that of the modules that depend
# on this module. The modules that depend no this module, however, will 
# automatically link with the linked_modules. 
# Note that the included_modules list is automatically added to the 
# linked_modules list, so that you do not need to list in linked_modules
# the modules that are already listed in included_modules.
# If a module needs to export an include path to its dependents that
# is not a module that the dependent can link with (ex: an include dir),
# list it in the included_only_modules.
# To summarize: included_modules should list all the modules that users
# of the public interface should depend on; linked_modules should list
# all the modules not listed in included_modules that are used by the
# module's implementation only.
#######################################################

############################# Atomix
ATX_SOURCE_ROOT = 'Atomix/Source'         
SourceDirLookup[ATX_SOURCE_ROOT] = '#/../Atomix/Source'  
if env['build_config'] == 'Debug':
    ATX_EXTRA_CPP_DEFINES = {'ATX_DEBUG':None}
else:
    ATX_EXTRA_CPP_DEFINES = {}
    
BuildModule(name                  = 'Atomix',
            build_source_dirs     = ['Core'],
            build_source_files    = env['ATX_SYSTEM_SOURCES'],
            included_only_modules = [ATX_SOURCE_ROOT+'/'+dir for dir in ['Config', 'Atomix']],
            linked_modules        = env['ATX_EXTRA_LIBS'],
            source_root           = ATX_SOURCE_ROOT,
            extra_cpp_defines     = ATX_EXTRA_CPP_DEFINES)

############################ Neptune
NPT_SOURCE_ROOT = 'Neptune/Source'
SourceDirLookup[NPT_SOURCE_ROOT] = '#/../Neptune/Source'  
if env['build_config'] == 'Debug':
    NPT_EXTRA_CPP_DEFINES = {'NPT_DEBUG':None}
else:
    NPT_EXTRA_CPP_DEFINES = {}
BuildModule(name                  = 'Neptune',
            build_source_dirs     = ['Core'],
            build_source_files    = env['NPT_SYSTEM_SOURCES'],
            included_only_modules = [NPT_SOURCE_ROOT+'/'+dir for dir in ['Config', 'Neptune']],
            linked_modules        = env['NPT_EXTRA_LIBS'],
            source_root           = NPT_SOURCE_ROOT,
            extra_cpp_defines     = NPT_EXTRA_CPP_DEFINES)

############################ Bento4
AP4_SOURCE_ROOT = 'Bento4/Source/C++'
SourceDirLookup[AP4_SOURCE_ROOT] = '#/../Bento4/Source/C++'  
if env['build_config'] == 'Debug':
    AP4_EXTRA_CPP_DEFINES = {'AP4_DEBUG':None}
else:
    AP4_EXTRA_CPP_DEFINES = {}
BuildModule(name                  = 'Bento4',
            build_source_dirs     = ['Core', 'MetaData', 'Crypto'],
            build_source_files    = env['AP4_SYSTEM_SOURCES'],
            included_only_modules = [AP4_SOURCE_ROOT+'/'+dir for dir in ['Config', 'Core', 'MetaData', 'Crypto']],
            source_root           = AP4_SOURCE_ROOT,
            extra_cpp_defines     = AP4_EXTRA_CPP_DEFINES)

############################ Melo
MLO_SOURCE_ROOT = 'Melo/Source'
SourceDirLookup[MLO_SOURCE_ROOT] = '#/../Melo/Source'  
if env.has_key('MLO_CPP_DEFINES'):
    MLO_EXTRA_CPP_DEFINES = env['MLO_CPP_DEFINES'] 
else:
    MLO_EXTRA_CPP_DEFINES = {}

if env['build_config'] == 'Debug':
    MLO_EXTRA_CPP_DEFINES['MLO_DEBUG'] = None

BuildModule(name              = 'Melo',
            build_source_dirs = ['.'],
            source_root       = MLO_SOURCE_ROOT,
            extra_cpp_defines = MLO_EXTRA_CPP_DEFINES)

############################# Fluo
if (env['FLO_DECODER_ENGINE'] == 'FLO_DECODER_ENGINE_MPG123'):
    BuildModule(name        = 'FloDecoderEngine',
                source_root = 'ThirdParty/mpg123/mpglib')
    fluo_decoder_deps = ['FloDecoderEngine']
    fluo_decoder_lib_dirs = []
    fluo_decoder_inc_dirs = []
elif (env['FLO_DECODER_ENGINE'] == 'FLO_DECODER_ENGINE_FFMPEG'):
    fluo_decoder_deps = ['avcodec']
    fluo_decoder_lib_dirs = ['ThirdParty/ffmpeg/Targets/'+env['target']+'/lib']
    fluo_decoder_inc_dirs = ['ThirdParty/ffmpeg/Targets/'+env['target']+'/include']
else:
    raise 'FLO_DECODER_ENGINE not set'

BuildModule(name               = 'Fluo',
            build_source_dirs  = ['Fluo'],
            build_include_dirs = fluo_decoder_inc_dirs,
            linked_modules     = ['Atomix'] + fluo_decoder_deps,
            extra_cpp_defines  = {'FLO_DECODER_ENGINE':env['FLO_DECODER_ENGINE']},
            extra_lib_dirs     = fluo_decoder_lib_dirs)

############################# Core
BuildModule(name                  = 'BltCore',
            build_source_dirs     = ['Core'],
            included_only_modules = ['Source/Config'],
            linked_modules        = ['Atomix', 'Neptune'])

############################# Decoder
BuildModule(name               = 'BltDecoder',
            build_source_dirs  = ['Decoder'],
            linked_modules     = ['Atomix', 'Neptune', 'BltCore'])

############################# Player
BuildModule(name               = 'BltPlayer',
            build_source_dirs  = ['Player'],
            linked_modules     = ['Atomix', 'Neptune', 'BltCore', 'BltDecoder'])

############################ WmaDecoder Plugin
if os.environ.has_key('WMSDK_HOME'):
    WMA_SOURCE_ROOT = 'WMSDK/WMPK/WMA9DEC'
    SourceDirLookup[WMA_SOURCE_ROOT] = '#/../WMSDK/WMPK/WMA9DEC'
    WMA_EXTRA_CPP_DEFINES = {'BUILD_INT_FLOAT':None, 
                         'ENABLE_LPC':None,
                         'ENABLE_ALL_ENCOPT':None,
                         'DISABLE_OPT':None,
                         'BITSTREAM_CORRUPTION_ASSERTS':None,
                         'BUILD_WMASTD':None,
                         'BUILD_WMAPRO':None,
                         'BUILD_WMALSL':None,
                         'BUILD_WMAPRO_PLLM':None,
                         'WMAAPI_NO_DRM':None,
                         'WMAAPI_NO_DRM_STREAM':None}  
    if env['build_config'] == 'Release':
        WMA_EXTRA_CPP_DEFINES['NDEBUG'] = None
    wma_env = env.has_key('WMA_ENV') and env['WMA_ENV'] or None
    BuildModule(name           = 'BltWmaDecoder',
            build_source_files = {'/Source/Plugins/Decoders/WMA':'*.c'},
            build_source_dirs  = ['audio/wmaudio/v9/asfparse_s',
                                  'audio/wmaudio/v9/common',
                                  'audio/wmaudio/v9/include',
                                  'audio/wmaudio/v9/decoder',
                                  'audio/wmaudio/v9/fmthlpr',
                                  'audio/wmaudio/v9/win32/decoder'],
            build_include_dirs = [WMA_SOURCE_ROOT+'/'+x for x in 
                                  ['mf/common/include',
                                   'audio/common/include',
                                   'audio/wmaudio/v9/common/include',
                                   'audio/wmaudio/v9/asfparse_s',
                                   'audio/wmaudio/v9/common',
                                   'audio/wmaudio/v9/decoder',
                                   'audio/wmaudio/v9/fmthlpr',
                                   'audio/wmaudio/v9/include',
                                   'audio/wmaudio/v9/win32']],
            included_only_modules = 'Source/Plugins/Decoders/WMA',
            linked_modules        = ['Atomix', 'BltCore'],
            source_root           = WMA_SOURCE_ROOT,
            environment           = wma_env,
            extra_cpp_defines     = WMA_EXTRA_CPP_DEFINES)
elif os.environ.has_key('BLT_WMA_PLUGIN_HOME'):
    BLT_EXTRAS_ROOT = os.environ['BLT_WMA_PLUGIN_HOME']
    Module(name             = 'BltWmaDecoder',
           included_modules = 'Source/Plugins/Decoders/WMA',
           linked_modules   = 'BltWmaDecoderPlugin',
           lib_dirs         = [BLT_EXTRAS_ROOT+'/Targets/'+env['target']+'/lib/'+env['build_config']])
#else:
#    if 'WmaDecoder' in env['BLT_PLUGINS']:
#        raise 'ERROR: the WmaDecoder plugin requires WMSDK_HOME or BLT_WMA_PLUGIN_HOME'
           
############################# BltPluginsSupport
BuildModule(name               = 'BltPluginsSupport',
            build_source_files = {'Plugins/Common':'BltReplayGain.c'},
            linked_modules     = ['Atomix', 'Neptune', 'BltCore'])
                 
############################# Plugins
PluginsSettings = {
    'FileInput'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_FILE_INPUT',         'src_dir':'Inputs/File'              },
    'CddaInput'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_CDDA_INPUT',         'src_dir':'Inputs/CDDA'              },
    'AlsaInput'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_ALSA_INPUT',         'src_dir':'Inputs/Alsa'              },
    'FileOutput'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_FILE_OUTPUT',        'src_dir':'Outputs/File'             },
    'OssOutput'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_OSS_OUTPUT',         'src_dir':'Outputs/OSS'              },
    'AlsaOutput'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_ALSA_OUTPUT',        'src_dir':'Outputs/Alsa'             },
    'DebugOutput'      : {'flags':'BLT_CONFIG_MODULES_ENABLE_DEBUG_OUTPUT',       'src_dir':'Outputs/Debug'            },
    'NullOutput'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_NULL_OUTPUT',        'src_dir':'Outputs/Null'             },
    'MpegAudioDecoder' : {'flags':'BLT_CONFIG_MODULES_ENABLE_MPEG_AUDIO_DECODER', 'src_dir':'Decoders/MpegAudio'       },
    'FlacDecoder'      : {'flags':'BLT_CONFIG_MODULES_ENABLE_FLAC_DECODER',       'src_dir':'Decoders/FLAC'            },
    'VorbisDecoder'    : {'flags':'BLT_CONFIG_MODULES_ENABLE_VORBIS_DECODER',     'src_dir':'Decoders/Vorbis'          },
    'AacDecoder'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_AAC_DECODER',        'src_dir':'Decoders/AAC'             },
    'WmaDecoder'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_WMA_DECODER',                                             },
    'WaveParser'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_WAVE_PARSER',        'src_dir':'Parsers/Wave'             },
    'AiffParser'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_AIFF_PARSER',        'src_dir':'Parsers/Aiff'             },
    'TagParser'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_TAG_PARSER',         'src_dir':'Parsers/Tags'             },
    'Mp4Parser'        : {'flags':'BLT_CONFIG_MODULES_ENABLE_MP4_PARSER',         'src_dir':'Parsers/Mp4'              },
    'WaveFormatter'    : {'flags':'BLT_CONFIG_MODULES_ENABLE_WAVE_FORMATTER',     'src_dir':'Formatters/Wave'          },
    'GainControlFilter': {'flags':'BLT_CONFIG_MODULES_ENABLE_GAIN_CONTROL_FILTER','src_dir':'Filters/GainControl'      },
    'PcmAdapter'       : {'flags':'BLT_CONFIG_MODULES_ENABLE_PCM_ADAPTER',        'src_dir':'Adapters/PCM'             },
    'SilenceRemover'   : {'flags':'BLT_CONFIG_MODULES_ENABLE_SILENCE_REMOVER',    'src_dir':'General/SilenceRemover'   },
    'StreamPacketizer' : {'flags':'BLT_CONFIG_MODULES_ENABLE_STREAM_PACKETIZER',  'src_dir':'General/StreamPacketizer' },
    'PacketStreamer'   : {'flags':'BLT_CONFIG_MODULES_ENABLE_PACKET_STREAMER',    'src_dir':'General/PacketStreamer'   }
}
PluginsExtras = {
    'Mp4Parser':        {'dep_mods':['Bento4']},   
    'FlacDecoder':      {'inc_dirs':['ThirdParty/FLAC/Targets/'+env['target']+'/include']},
    'MpegAudioDecoder': {'dep_mods':['Fluo']},   
    'AacDecoder':       {'dep_mods':['Melo']},   
    'FlacDecoder':      {'inc_dirs':['ThirdParty/FLAC/Targets/'+env['target']+'/include'],
                         'lib_dirs':['ThirdParty/FLAC/Targets/'+env['target']+'/lib'],
                         'dep_mods':['FLAC']},
    'VorbisDecoder':    {'inc_dirs':['ThirdParty/Vorbis/Targets/'+env['target']+'/include'],
                         'lib_dirs':['ThirdParty/Vorbis/Targets/'+env['target']+'/lib'],
                         'dep_mods':['vorbisfile','vorbis','ogg']},
    'AlsaOutput':       {'dep_mods':['asound']},   
    'AlsaInput':        {'dep_mods':['asound']},
}
if 'CddaInput' in env['BLT_PLUGINS']:
    PluginsExtras['CddaInput'] = {'src_dirs':['Plugins/Inputs/CDDA/'+env['BLT_PLUGINS_CDDA_DEVICE_TYPE']]}

if 'VorbisDecoder' in env['BLT_PLUGINS'] and env.has_key('BLT_PLUGINS_VORBIS_LIBRARY'):
    print "******************", env['BLT_PLUGINS_VORBIS_LIBRARY']
    if env['BLT_PLUGINS_VORBIS_LIBRARY'] == 'Tremor':
        PluginsExtras['VorbisDecoder']['dep_mods'] = ['vorbisidec']
        PluginsExtras['VorbisDecoder']['flags'] = {'BLT_CONFIG_VORBIS_USE_TREMOR':None}

for plugin in env['BLT_PLUGINS']:
    if not PluginsSettings[plugin].has_key('src_dir'): continue # skip binary only plugins
    extra_includes = []
    extra_dep_mods = []
    extra_lib_dirs = []
    extra_src_dirs = []
    extra_flags    = {}
    extra_env      = None
    if PluginsExtras.has_key(plugin):
        if PluginsExtras[plugin].has_key('inc_dirs'): extra_includes += PluginsExtras[plugin]['inc_dirs']
        if PluginsExtras[plugin].has_key('dep_mods'): extra_dep_mods += PluginsExtras[plugin]['dep_mods']
        if PluginsExtras[plugin].has_key('lib_dirs'): extra_lib_dirs = PluginsExtras[plugin]['lib_dirs']
        if PluginsExtras[plugin].has_key('src_dirs'): extra_src_dirs = PluginsExtras[plugin]['src_dirs']
        if PluginsExtras[plugin].has_key('flags'):    extra_flags    = PluginsExtras[plugin]['flags']
        if PluginsExtras[plugin].has_key('env'):      extra_env      = PluginsExtras[plugin]['env']
    BuildModule(name               = 'Blt'+plugin,
                build_source_dirs  = ['Plugins/'+PluginsSettings[plugin]['src_dir']]+extra_src_dirs,
                build_include_dirs = ['Source/Plugins/Common', 'Source/Config']+extra_includes,
                linked_modules     = extra_dep_mods,
                included_modules   = ['Atomix', 'Neptune', 'BltCore', 'BltPluginsSupport'],
                extra_lib_dirs     = extra_lib_dirs,
                extra_cpp_defines  = extra_flags,
                environment        = extra_env)

plugins_cpp_defines = dict([[PluginsSettings[p]['flags'], None] for p in env['BLT_PLUGINS']])
plugins_cpp_defines['BLT_CONFIG_MODULES_DEFAULT_OUTPUT_NAME'] = '\\"'+env['BLT_DEFAULT_OUTPUT']+'\\"'

BuildModule(name               = 'BltPlugins',
            build_source_files = {'Plugins/Common':'BltBuiltins.c'},
            linked_modules     = ['Atomix', 'BltCore', 'BltPluginsSupport']+['Blt'+p for p in env['BLT_PLUGINS']],
            extra_cpp_defines  = plugins_cpp_defines)

############################# BtPlay
BuildModule(name               = 'BtPlay',
            type               = 'Executable',
            build_source_dirs  = ['Apps/BtPlay'],
            build_include_dirs = ['Source/BlueTune', 'Source/Config'],
            linked_modules     = ['Atomix', 'Neptune', 'BltCore', 'BltDecoder', 'BltPlugins'])

############################# BtController
BuildModule(name               = 'BtController',
            type               = 'Executable',
            build_source_dirs  = ['Apps/BtController'],
            build_include_dirs = ['Source/BlueTune', 'Source/Config'],
            linked_modules     = ['Atomix', 'Neptune', 'BltCore', 'BltDecoder', 'BltPlayer', 'BltPlugins'])

############################# BtGtk
#gtk_env = env.Copy()
#gtk_env.ParseConfig('pkg-config --cflags gtk+-2.0')
BuildModule(name               = 'BtGtk',
            type               = 'Executable',
            build_source_dirs  = ['Apps/BtGtk'],
            build_include_dirs = ['Source/BlueTune', 'Source/Config',
                                  '/usr/include/gtk-2.0',
                                  '/usr/lib/gtk-2.0/include',
                                  '/usr/include/atk-1.0',
                                  '/usr/include/cairo',
                                  '/usr/include/pango-1.0',
                                  '/usr/include/glib-2.0',
                                  '/usr/lib/glib-2.0/include'],
            linked_modules     = ['Atomix', 'Neptune', 'BltCore', 'BltDecoder', 'BltPlayer', 'BltPlugins',
                                  'gtk-x11-2.0', 
                                  'gdk-x11-2.0', 
                                  'atk-1.0', 
                                  'gdk_pixbuf-2.0', 
                                  'pangocairo-1.0',
                                  'fontconfig',
                                  'Xext',
                                  'Xrender',
                                  'Xinerama',
                                  'Xi',
                                  'Xrandr',
                                  'Xcursor',
                                  'Xfixes',
                                  'pango-1.0',
                                  'cairo', 
                                  'X11',    
                                  'gobject-2.0',
                                  'gmodule-2.0', 
                                  'dl', 
                                  'glib-2.0'])
